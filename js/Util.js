Array.prototype.intersect=function(...t){for(const e of t)if(!Array.isArray(e))throw"This function only accepts Array objects!";return this.filter(e=>{let s=!0;for(let i=0;i<t.length&&s;i++)s=t[i].includes(e);return s})},Array.prototype.reverseMiddle=function(){const t=this.slice(1,this.length-1);for(let e=0;e<t.length;e+=2)[t[e],t[e+1]]=[t[e+1],t[e]];return[this[0],...t,this[this.length-1]]},String.prototype.toCamelCase=function(){return this.replace(/(_\w)/g,t=>t[1].toUpperCase())},Number.prototype.maybeRound=function(t){return parseFloat(this.toFixed(t))};class t{constructor(){throw new Error("This class isn't supposed to be initialized")}static resolveRequire(t,e,s){return s.get("system.requires."+t)({rep:{name:e}})}static setParams(...t){const e=new URLSearchParams(window.location.search);for(const[s,i]of t)e.set(s,i);return e}static makeState(t,e,s){const i={skills:e.skills.toJSON(),armor:e.armor,perkDeck:e.perkDeck,throwable:e.throwable,deployable:e.deployable,deployableSecondary:e.deployableSecondary};return s&&(i.tab=s),t&&(i.lang=t),i}static getNodeIndex(t,e=(()=>!0)){return[...t.parentNode.children].filter(e).indexOf(t)}static parentElement(t,e=1){let s=t;for(let t=0;t<e;t++)s=s.parentElement;return s}static findTouch(t,e){for(const s of t)if(s.identifier===e)return s;return!1}}class e extends Map{constructor(...t){super(...t),this.points=120}getTierPoints(t,e,s){let i=0;for(const[n,o]of this){const r=s.get(n);r.subtree===e&&r.tier===t&&(2===o.state?i+=r.ace+r.basic:i+=r.basic)}return i}getTiersToFloorPoints(t,e,s){let i=0;for(let n=0;n<=t;n++)i+=this.getTierPoints(n,e,s);return i}toJSON(){const t={};for(const[e,s]of this)t[e]=s;return t}}class s extends Map{fetchAll(){const t=[];for(const[e]of this)t.push(fetch(`./db/${e}.json`).then(t=>t.json()).then(t=>{if("skills"===e||"perk_decks"===e)for(const i in t)t[i].stats&&("skills"===e?(t[i].stats.basic&&s.processModifiers(...t[i].stats.basic),t[i].stats.ace&&s.processModifiers(...t[i].stats.ace)):s.processModifiers(...t[i].stats));this.set(e,new Map(Object.entries(t)))}));return Promise.all(t)}static processModifiers(...t){for(const e of t)if(e&&"string"==typeof e.value)return Function.apply({},[...e.arguments,`return (${e.value})`])}}class i{constructor(t){this.builder=t}Skill_Add(t){const e=this.builder.exp,s=e.skills.get(t),n=this.builder.dbs.get("skills").get(t),o=e.subtrees[n.subtree];if(s){if(e.skills.points-n.ace>=0)return o.points+=n.ace,e.skills.points-=n.ace,s.state=2,o.tier=i.getSubtreeTierLevel(o.points),!0}else if(e.skills.points-n.basic>=0)return o.points+=n.basic,e.skills.points-=n.basic,e.skills.set(t,{state:1}),o.tier=i.getSubtreeTierLevel(o.points),!0;return!1}Skill_Remove(t){const e=this.builder.exp,s=e.skills.get(t),n=this.builder.dbs.get("skills"),o=n.get(t);if(!s)return!1;for(let t=o.tier;t<4;t++)if(0!==e.skills.getTierPoints(t+1,o.subtree,n)){const i=e.skills.getTiersToFloorPoints(t,o.subtree,n);if(2===s.state){if(i-o.ace<this.constructor.TIER_UTIL[t])return!1}else if(i-o.basic<this.constructor.TIER_UTIL[t])return!1}const r=e.subtrees[o.subtree];return 2===s.state?(r.points-=o.ace,e.skills.points+=o.ace,s.state=1):1===s.state&&(r.points-=o.basic,e.skills.points+=o.basic,e.skills.delete(t)),r.tier=i.getSubtreeTierLevel(r.points),!0}static getSubtreeTierLevel(t){let e=this.TIER_UTIL.findIndex(e=>t<=e);return-1===e&&(e=this.TIER_UTIL.length),e}}i.TIER_UTIL=[0,1,3,16];class n{constructor(){this.down=!1,this.contexts=[],this.curContext,document.addEventListener("mouseup",t=>{this.down&&0==t.button&&(t.preventDefault(),this.down=!1)}),document.addEventListener("mousemove",t=>{this.down&&this.curContext.element.scrollBy(t.movementX*this.curContext.multiply,0)},{passive:!0})}addContext(t,e=1,s=!0){const i={element:t,propagate:s,multiply:e};this.contexts.push(i),t.addEventListener("mousedown",t=>{0==t.button&&(this.down=!0,this.curContext=i,!s&&t.target.closest(".pk_deck_cards > div")&&t.stopPropagation(),t.preventDefault())})}}class o{constructor({click:e=(()=>i.dispatchEvent(new MouseEvent("click",{detail:-1}))),double:s=(()=>i.dispatchEvent(new MouseEvent("contextmenu",{detail:-1}))),element:i,mobile:n,hold:o,propagate:r=!1}){this.touchId=null,this.last=[],this.remaining=[],this.holding=!1,this.didDouble=!1,this.listen=!1;const l=t=>{if(t instanceof MouseEvent){if(r||t.stopPropagation(),0!=t.button)return}else{if(t.stopImmediatePropagation(),null!==this.touchId)return;const e=t.touches[0];this.touchId=e.identifier,this.last=[e.clientX,e.clientY]}this.remaining=[2*document.documentElement.clientWidth/100,2*document.documentElement.clientHeight/100],this.holding=setTimeout(()=>{this.holding=!0,this.touchId=null,this.listen=!1,o()},750),this.listen=!0},c=e=>{if(this.listen){if(e instanceof MouseEvent)this.remaining[0]-=Math.abs(e.movementX),this.remaining[1]-=Math.abs(e.movementY);else{const s=t.findTouch(e.changedTouches,this.touchId);if(!s)return;this.remaining[0]-=Math.abs(s.clientX-this.last[0]),this.remaining[1]-=Math.abs(s.clientY-this.last[1]),this.last=[s.clientX,s.clientY]}this.remaining.some(t=>t<=0)&&(clearTimeout(this.holding),this.touchId=null,this.listen=!1)}},a=i=>{if(!(!this.listen||i instanceof MouseEvent&&0!==i.button||i.touches&&t.findTouch(i.touches,this.touchId))){if(i.stopImmediatePropagation(),clearTimeout(this.holding),i instanceof MouseEvent)return this.listen=!1,void(this.touchId=null);if(this.didDouble)return this.didDouble=!1,this.touchId=null,this.listen=!1,void s();this.didDouble=!0,setTimeout(()=>{this.didDouble&&(this.listen=!1,this.touchId=null,this.didDouble=!1,e())},250)}};i.addEventListener("touchstart",l),i.addEventListener("touchcancel",()=>this.touchId=null),i.addEventListener("touchmove",c),i.addEventListener("touchend",a),n&&(i.addEventListener("mouseup",a),i.addEventListener("mousemove",c),i.addEventListener("mousedown",l))}}export{t as default,e as SkillMap,s as DBMap,i as System,n as XScrollTransformer,o as UIEventHandler};
